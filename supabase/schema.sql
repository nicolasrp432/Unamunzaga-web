-- Enable Row Level Security
alter default privileges in schema public grant all on tables to postgres, anon, authenticated, service_role;

-- PROFILES (Users)
create table public.profiles (
  id uuid references auth.users not null primary key,
  email text,
  full_name text,
  role text default 'client', -- 'client' or 'admin'
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.profiles enable row level security;

create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

create policy "Users can insert their own profile."
  on profiles for insert
  with check ( auth.uid() = id );

create policy "Users can update own profile."
  on profiles for update
  using ( auth.uid() = id );

-- CONTACTS (Leads)
create table public.contacts (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  name text not null,
  email text not null,
  phone text,
  service text,
  message text,
  status text default 'new' -- 'new', 'contacted', 'closed'
);

alter table public.contacts enable row level security;

create policy "Anyone can insert contacts."
  on contacts for insert
  with check ( true );

create policy "Only admins can view contacts."
  on contacts for select
  using ( auth.uid() in (select id from profiles where role = 'admin') );

-- PROJECTS (For Dashboard)
create table public.projects (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  title text not null,
  client_id uuid references public.profiles(id),
  status text default 'planning', -- 'planning', 'in_progress', 'completed'
  start_date date,
  end_date date,
  description text,
  address text
);

alter table public.projects enable row level security;

create policy "Admins can do everything with projects."
  on projects for all
  using ( auth.uid() in (select id from profiles where role = 'admin') );

create policy "Clients can view their own projects."
  on projects for select
  using ( auth.uid() = client_id );

-- PROJECT UPDATES (Timeline)
create table public.project_updates (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  project_id bigint references public.projects(id) not null,
  title text not null,
  description text,
  image_url text,
  date date default now()
);

alter table public.project_updates enable row level security;

create policy "Admins can manage updates."
  on project_updates for all
  using ( auth.uid() in (select id from profiles where role = 'admin') );

create policy "Clients can view updates for their projects."
  on project_updates for select
  using ( project_id in (select id from projects where client_id = auth.uid()) );

-- DOCUMENTS
create table public.documents (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  project_id bigint references public.projects(id) not null,
  name text not null,
  url text not null,
  type text -- 'invoice', 'plan', 'contract'
);

alter table public.documents enable row level security;

create policy "Admins can manage documents."
  on documents for all
  using ( auth.uid() in (select id from profiles where role = 'admin') );

create policy "Clients can view documents for their projects."
  on documents for select
  using ( project_id in (select id from projects where client_id = auth.uid()) );

-- Function to handle new user signup
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, full_name, role)
  values (new.id, new.email, new.raw_user_meta_data->>'full_name', 'client');
  return new;
end;
$$ language plpgsql security definer;

-- Trigger for new user signup
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
